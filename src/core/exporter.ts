import { join } from 'path';
import { readJSON, writeMarkdown, writeJSON, fileExists } from '../utils/fs.js';
import { CONTEXT_DIR, CONTEXT_FILES } from '../constants.js';
import type { Project, Stack, Architecture, Constraints, Decisions } from '../schema/index.js';

export async function exportToMarkdown(rootDir: string): Promise<string> {
  const contextDir = join(rootDir, CONTEXT_DIR);
  
  let markdown = '# Project Context\n\n';
  markdown += '> Generated by Prelude\n\n';
  markdown += '---\n\n';
  
  // Project metadata
  const projectPath = join(contextDir, CONTEXT_FILES.PROJECT);
  if (await fileExists(projectPath)) {
    const project = await readJSON<Project>(projectPath);
    markdown += '## ðŸ“‹ Project Overview\n\n';
    markdown += `**Name:** ${project.name}\n\n`;
    markdown += `**Description:** ${project.description}\n\n`;
    if (project.version) markdown += `**Version:** ${project.version}\n\n`;
    if (project.repository) markdown += `**Repository:** ${project.repository}\n\n`;
    if (project.license) markdown += `**License:** ${project.license}\n\n`;
    
    if (project.goals && project.goals.length > 0) {
      markdown += '**Goals:**\n';
      project.goals.forEach(goal => {
        markdown += `- ${goal}\n`;
      });
      markdown += '\n';
    }
    
    markdown += '---\n\n';
  }
  
  // Stack information
  const stackPath = join(contextDir, CONTEXT_FILES.STACK);
  if (await fileExists(stackPath)) {
    const stack = await readJSON<Stack>(stackPath);
    markdown += '## ðŸ”§ Technology Stack\n\n';
    markdown += `**Language:** ${stack.language}\n\n`;
    if (stack.runtime) markdown += `**Runtime:** ${stack.runtime}\n\n`;
    if (stack.packageManager) markdown += `**Package Manager:** ${stack.packageManager}\n\n`;
    
    if (stack.frameworks && stack.frameworks.length > 0) {
      markdown += '**Frameworks:**\n';
      stack.frameworks.forEach(fw => {
        markdown += `- ${fw}\n`;
      });
      markdown += '\n';
    }
    
    if (stack.testingFrameworks && stack.testingFrameworks.length > 0) {
      markdown += '**Testing:**\n';
      stack.testingFrameworks.forEach(tf => {
        markdown += `- ${tf}\n`;
      });
      markdown += '\n';
    }
    
    if (stack.styling && stack.styling.length > 0) {
      markdown += '**Styling:**\n';
      stack.styling.forEach(s => {
        markdown += `- ${s}\n`;
      });
      markdown += '\n';
    }
    
    if (stack.database) markdown += `**Database:** ${stack.database}\n\n`;
    if (stack.orm) markdown += `**ORM:** ${stack.orm}\n\n`;
    
    markdown += '---\n\n';
  }
  
  // Architecture
  const archPath = join(contextDir, CONTEXT_FILES.ARCHITECTURE);
  if (await fileExists(archPath)) {
    const arch = await readJSON<Architecture>(archPath);
    markdown += '## ðŸ—ï¸ Architecture\n\n';
    if (arch.type) markdown += `**Type:** ${arch.type}\n\n`;
    if (arch.routing) markdown += `**Routing:** ${arch.routing}\n\n`;
    if (arch.apiStyle) markdown += `**API Style:** ${arch.apiStyle}\n\n`;
    
    if (arch.patterns && arch.patterns.length > 0) {
      markdown += '**Patterns:**\n';
      arch.patterns.forEach(p => {
        markdown += `- ${p}\n`;
      });
      markdown += '\n';
    }
    
    if (arch.directories && arch.directories.length > 0) {
      markdown += '**Key Directories:**\n';
      arch.directories.slice(0, 10).forEach(dir => {
        markdown += `- \`${dir.path}\``;
        if (dir.purpose) markdown += ` - ${dir.purpose}`;
        markdown += '\n';
      });
      markdown += '\n';
    }
    
    markdown += '---\n\n';
  }
  
  // Constraints
  const constraintsPath = join(contextDir, CONTEXT_FILES.CONSTRAINTS);
  if (await fileExists(constraintsPath)) {
    const constraints = await readJSON<Constraints>(constraintsPath);
    markdown += '## âš ï¸ Constraints & Preferences\n\n';
    
    if (constraints.mustUse && constraints.mustUse.length > 0) {
      markdown += '**Must Use:**\n';
      constraints.mustUse.forEach(item => {
        markdown += `- ${item}\n`;
      });
      markdown += '\n';
    }
    
    if (constraints.mustNotUse && constraints.mustNotUse.length > 0) {
      markdown += '**Must Not Use:**\n';
      constraints.mustNotUse.forEach(item => {
        markdown += `- ${item}\n`;
      });
      markdown += '\n';
    }
    
    if (constraints.codeStyle) {
      markdown += '**Code Style:**\n';
      if (constraints.codeStyle.formatter) markdown += `- Formatter: ${constraints.codeStyle.formatter}\n`;
      if (constraints.codeStyle.linter) markdown += `- Linter: ${constraints.codeStyle.linter}\n`;
      markdown += '\n';
    }
    
    if (constraints.testing) {
      markdown += '**Testing Requirements:**\n';
      markdown += `- Required: ${constraints.testing.required ? 'Yes' : 'No'}\n`;
      if (constraints.testing.strategy) markdown += `- Strategy: ${constraints.testing.strategy}\n`;
      markdown += '\n';
    }
    
    markdown += '---\n\n';
  }
  
  // Decisions
  const decisionsPath = join(contextDir, CONTEXT_FILES.DECISIONS);
  if (await fileExists(decisionsPath)) {
    const decisions = await readJSON<Decisions>(decisionsPath);
    if (decisions.decisions && decisions.decisions.length > 0) {
      markdown += '## ðŸ§  Key Decisions\n\n';
      
      // Show most recent 5 decisions
      const recentDecisions = decisions.decisions.slice(-5).reverse();
      recentDecisions.forEach(decision => {
        markdown += `### ${decision.title}\n\n`;
        markdown += `**Status:** ${decision.status}\n\n`;
        markdown += `**Rationale:** ${decision.rationale}\n\n`;
        
        if (decision.alternatives && decision.alternatives.length > 0) {
          markdown += '**Alternatives Considered:**\n';
          decision.alternatives.forEach(alt => {
            markdown += `- ${alt}\n`;
          });
          markdown += '\n';
        }
        
        if (decision.impact) markdown += `**Impact:** ${decision.impact}\n\n`;
        markdown += '---\n\n';
      });
    }
  }
  
  markdown += '\n*End of context export*\n';
  
  return markdown;
}

export async function exportToJSON(rootDir: string): Promise<object> {
  const contextDir = join(rootDir, CONTEXT_DIR);
  const exportData: any = {};
  
  // Read all context files
  const files = [
    { key: 'project', file: CONTEXT_FILES.PROJECT },
    { key: 'stack', file: CONTEXT_FILES.STACK },
    { key: 'architecture', file: CONTEXT_FILES.ARCHITECTURE },
    { key: 'constraints', file: CONTEXT_FILES.CONSTRAINTS },
    { key: 'decisions', file: CONTEXT_FILES.DECISIONS }
  ];
  
  for (const { key, file } of files) {
    const filePath = join(contextDir, file);
    if (await fileExists(filePath)) {
      exportData[key] = await readJSON(filePath);
    }
  }
  
  return exportData;
}

export async function saveExport(rootDir: string, format: 'md' | 'json' = 'md'): Promise<string> {
  const contextDir = join(rootDir, CONTEXT_DIR);
  
  if (format === 'md') {
    const markdown = await exportToMarkdown(rootDir);
    const exportPath = join(contextDir, CONTEXT_FILES.EXPORT_MD);
    await writeMarkdown(exportPath, markdown);
    return exportPath;
  } else {
    const json = await exportToJSON(rootDir);
    const exportPath = join(contextDir, CONTEXT_FILES.EXPORT_JSON);
    await writeJSON(exportPath, json);
    return exportPath;
  }
}